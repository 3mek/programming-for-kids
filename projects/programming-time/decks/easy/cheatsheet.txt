ASCII TABLE:

32  SPC   64  @    96  `
33  !     65  A    97  a
34  "     66  B    98  b
35  #     67  C    99  c
36  $     68  D   100  d
37  %     69  E   101  e
38  &     70  F   102  f
39  '     71  G   103  g
40  (     72  H   104  h
41  )     73  I   105  i
42  *     74  J   106  j
43  +     75  K   107  k
44  ,     76  L   108  l
45  -     77  M   109  m
46  .     78  N   110  n
47  /     79  O   111  o
48  0     80  P   112  p
49  1     81  Q   113  q
50  2     82  R   114  r
51  3     83  S   115  s
52  4     84  T   116  t
53  5     85  U   117  u
54  6     86  V   118  v
55  7     87  W   119  w
56  8     88  X   120  x
57  9     89  Y   121  y
58  :     90  Z   122  z
59  ;     91  [   123  {
60  <     92  \   124  |
61  =     93  ]   125  }
62  >     94  ^   126  ~
63  ?     95  _

####################################

Modulo (remainder) table
for A % B

 % | 0 1 2 3 4 5 6 7 8 9 B
---+--------------------
 0 | X 0 0 0 0 0 0 0 0 0
 1 | X 0 1 1 1 1 1 1 1 1
 2 | X 0 0 2 2 2 2 2 2 2
 3 | X 0 1 0 3 3 3 3 3 3
 4 | X 0 0 1 0 4 4 4 4 4 
 5 | X 0 1 2 1 5 5 5 5 5
 6 | X 0 0 0 2 1 0 6 6 6
 7 | X 0 1 1 3 2 1 0 7 7
 8 | X 0 0 2 0 3 2 1 0 8
 9 | X 0 1 0 1 4 3 2 1 0
 A

####################################

Computer Memory
In our game we made up 1 memory byte
per type,

1 -> integer  
2 -> string   
3 -> range    
4 -> list     
5 -> boolean  

When you store a value in memory,
python also puts down its type. In
the real python the type information
is much bigger, but the idea is the
same.

####################################
Functions

Functions are mini programs with a
name that you can call as many times
as you want.

Example:

# sum all elements from a list
# that are smaller than cutoff
def sum_cutoff(data,cutoff):
  r = 0
  for d in data:
    if d < cutoff:
      r += d
  return r

a = [1,2,4,2,4,2,199,1,1]
s1 = sum_cutoff(a, 10)
s2 = sum_cutoff(a, 2)

The way to declare a function is:

def func_name(param1,param2,..):
   func code
   ...
   ...
``

the function can take as many
parameters as you want.


####################################

Classes

Classes are blueprints of code that
describe what an object can do. 


class Dog:
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def bark(self):
    if self.age > 5:
      print(self.name + ' Woof!')
    else:
      print(self.name + ' oof!')

ruffles = Dog('Ruffles', 5)
ruffles.bark()

max = Dog('Ruffles', 3)
max.bark()

To make a new dog use
Dog('Ruffles',5), this calls the
__init__ function with magic
parameter self(the newlly created
dog), name and age. ruffles.bark()
will call the bark() method on the
object ruffles. Or you can make a
bark() function that takes a name
and age:

  def bark(name, age):
     if age > 5:
       print(name + 'Woof!')
     else:
       print(name + 'oof!')
  bark('Ruffles',5)

The first one is called object
oriented programming(OOP), and the
second is called procedural
programming.
