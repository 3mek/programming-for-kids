<script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.3.2/peerjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ext-themelist.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/mode-javascript.min.js"></script>




<style>
    body,
    pre,
    textarea {
        font-family: monospace;
        font-size: 14px;
        margin: 0;
    }

    tiny {
        font-family: monospace;
    }

    iframe {
        display: none
    }

    #loading {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: black;
        color: white;
    }

    #editor {
        display: none;
    }

    #error {
        color: white;
        background-color: tomato;
    }
</style>
<div id='loading'>
    <h1>
        戦
    </h1>
    <hr>
    <mark>
        The game allows the other player to run javascript code on your comupter.<br>
        Use at your own risk.
    </mark>
    <hr>
    <p>
        You need another player.
        Send them this link to play:
    </p>
</div>
<div style="margin: 5px">
    <pre id='help'>
<span style='font-size: 20px'>戦</span>
<small>* Each piece can move: freely horizontally, and +- 1 vertically
* If you collide with the enemy or yourself, you annihilate each other.
* Goal is to reach the end of the board with at least one piece.
* You are playing <b>x</b>, oponent is playing <b>0</b>
</small>
</pre>
    <div id='error'></div>
    <button disabled id='a_go'>play</button><br>
    <div id="editor" style="height: 150px; width: 100%"></div>

    <pre id='game'></pre>
    <textarea id='enemy_code' disabled rows=10 cols=80></textarea>
</div>
<iframe sandbox='allow-scripts' src="frame.html" id='frame'></iframe>
<script>
    const sleep = function (ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // XXX: this is horrible, idk how safe it is even through the iframe sandbox
    const evaluate = async function (code) {
        const frame = document.getElementById('frame')
        frame.contentWindow.postMessage(code, '*');

        let data = undefined
        const cb = function (e) { data = e.data }
        window.addEventListener('message', cb);
        while (!data) {
            await sleep(100)
        }
        window.removeEventListener('message', cb)
        return data
    }

    const width = 20
    const height = 20
    let entriesA = []
    let entriesB = []

    const key = function (x, y) {
        return x + '_' + y
    }

    const uuid = function () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    const to_positions = function (entries, cb) {
        let positions = {}
        for (let a of entries) {
            positions[key(a.x, a.y)] = cb(a)
        }
        return positions
    }

    const draw = function ({home,away}) {
        const positionsB = to_positions(entriesB, e => ' <span title="idx:'+e.index+'">0</span>|')
        const positionsA = to_positions(entriesA, e => ' <span title="idx:'+e.index+'">x</span>|')
        const view = document.getElementById('game')

        let text = '\nalive: x(' + entriesA.length + '), 0(' + entriesB.length + ')\n\n'
        const line_of_dashes = () => {
            for (let x = 0; x < width; x++) {
                text += '---'
            }
            text += '--\n'
        }
        const x_labels = () => {
            text += '  '
            for (let x = 0; x < width; x++) {
                text += (x + '').padStart(2, ' ') + '|'
            }
            text += '\n'
        }
        x_labels()
        line_of_dashes()

        for (let y = 0; y < height; y++) {
            text += (y + '').padStart(2, ' ')
            for (let x = 0; x < width; x++) {
                let k = key(x, y)
                text += positionsA[k] || positionsB[k] || '  |'
            }
            text += '\n'
        }
        line_of_dashes()
        x_labels()
        text += '\n'
        let win = ''
        for (e of entriesA) {
            if ((home && e.y == height - 1) || ((away && e.y == 0))) {
                win = '\n\nYOU WIN!\n\n'
            }
        }

        for (e of entriesB) {
            if ((away && e.y == height - 1) || ((home && e.y == 0))) {
                win = '\n\nYOU LOSE!\n\n'
            }
        }
        if (entriesB.length == 0) {
            win = '\n\nYOU WIN!\n\n'
        }
        if (entriesA.length == 0) {
            win = '\n\nYOU LOSE!\n\n'
        }
        if (win) {
            a_go.parentElement.removeChild(a_go)
        }
        view.innerHTML = win + text
    }

    const randint = function (min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min)
    }

    const reset_pieces = function (where) {
        let home = []
        let away = []
        for (let i = 0; i < width; i++) {
            home.push({ index: home.length, x: i, y: 0, id: 'id-a-' + key(i, 0) + '-' + Math.random() })

            away.push({ index: away.length, x: i, y: height - 1, id: 'id-b-' + key(i, height - 1) + '-' + Math.random() })
        }
        if (where == 'home') {
            entriesA = home
            entriesB = away
        } else {
            entriesB = home
            entriesA = away        
        }
    }


    const run = async (code, heroes, enemies) => {
        let result = await evaluate('(' + code + ')(' + JSON.stringify({ heroes, enemies, width, height }) + ')')
        if (result.error) {
            throw (result.error)
        }

        if (!Array.isArray(result)) return heroes

        // remove out of bounds
        for (let r of result) {
            if (r.x < 0) r.x = 0
            if (r.y < 0) r.y = 0
            if (r.x > width-1) r.y = width-1
            if (r.y > height-1) r.y = height-1
        }


        // remove invalid ids
        byID = {}

        for (let h of heroes) {
            byID[h.id] = h
        }

        byPosition = {}
        for (let r of result) {
            let k = key(r.x,r.y)
            if (byPosition[k]) {
                byPosition[k].delete = true
                r.delete = true
            } else {
                byPosition[k] = r
            }
        }

        result = result.filter(r => byID[r.id] && !r.delete)

        // check if positions differ too mucb
        for (let r of result) {
            let original = byID[r.id]

            // allow only step moves at a time
            if (Math.abs(r.y - original.y) > 1) {
                r.y = original.y;
            }
        }
        return result
    }

    let id = window.location.hash.substring(1)
    if (id.length < 3) {
        id = uuid() + '-a'
        window.location.hash = id
    }
    const peer = new Peer(id);
    const errorE = document.getElementById('error')
    const a_go = document.getElementById('a_go')
    const enemy_code = document.getElementById('enemy_code')
    const loading = document.getElementById('loading')
    const other = id.substring(0, id.length - 2) + (id.endsWith('-a') ? '-b' : '-a')
    loading.innerHTML += '<textarea style="color: white; background-color: black; border: 0px;resize: none" rows=1 disabled cols=100>' + window.location.href.split('#')[0] + '#' + other + '</textarea>'

    if (!confirm("This game allows another player to execute javascript code in sandboxed iframe on your computer, do you want to continue? [ USE AT YOUR OWN RISK ]")) {
        loading.innerHTML = 'understood!'
    } else {
        const reconnect_screen = () => {
            loading.innerHTML = 'connection closed, please refresh, and ask the other peer to refresh'
            loading.style.display = 'block'
            document.getElementById('editor').style.display = 'none'
        }
        peer.on('open', function (id) {
            let work = function (conn) {
                loading.style.display = 'none'
                document.getElementById("editor").style.display = 'block'
                var editor = ace.edit("editor");
                editor.getSession().setUseWorker(false);
                editor.setReadOnly(true)
                editor.getSession().setMode("ace/mode/javascript");

                var initial = `function evolve({ heroes, enemies, width, height }) {
    for (let h of heroes) {
        h.x += Math.random() > 0.5 ? -1 : 1
        h.y += Math.random() > 0.5 ? -1 : 1
    }
    return heroes
}`
                editor.setValue(initial)
                editor.clearSelection()
                enemy_code.value = initial
                is_home = id.endsWith('-a')
                is_away = id.endsWith('-b')
                if (is_home) {
                    a_go.removeAttribute('disabled')
                    editor.setReadOnly(false)
                    reset_pieces('home')
                } else {
                    reset_pieces('away')
                }
                draw({home: is_home, away: is_away})
                conn.on('data', async function (data) {
                    let parsed = JSON.parse(data)
                    entriesB = parsed.entriesA
                    entriesA = parsed.entriesB

                    enemy_code.value = parsed.code

                    try {
                        entriesB = await run(data, entriesB, entriesA)
                        let positionsB = to_positions(entriesB, e => true)
                        let positionsA = to_positions(entriesA, e => true)

                        entriesA = entriesA.filter(e => !positionsB[key(e.x, e.y)])
                        entriesB = entriesB.filter(e => !positionsA[key(e.x, e.y)])
                    } catch (e) {
                        console.error('b', e)
                    } finally {
                        a_go.removeAttribute('disabled')
                        editor.setReadOnly(false)
                        draw({home: is_home, away: is_away})
                    }
                });

                a_go.addEventListener('click', async () => {
                    errorE.innerHTML = ''
                    try {
                        entriesA = await run(editor.getValue(), entriesA, entriesB)
                        let positionsA = to_positions(entriesA, e => true)
                        let positionsB = to_positions(entriesB, e => true)

                        entriesB = entriesB.filter(e => !positionsA[key(e.x, e.y)])
                        entriesA = entriesA.filter(e => !positionsB[key(e.x, e.y)])
                        conn.send(JSON.stringify({ code: editor.getValue(), entriesA, entriesB }))

                        a_go.setAttribute('disabled', 'disabled')
                        editor.setReadOnly(true)
                        draw({home: is_home, away: is_away})
                    } catch (e) {
                        console.error('a', e)
                        errorE.innerHTML = 'error: ' + e
                    }
                })
            }

            if (id.endsWith('-a')) {
                let connected = false
                let prev = undefined
                setInterval(() => {
                    if (!connected) {
                        if (prev) prev.close()

                        let conn = peer.connect(other)
                        conn.on('open', () => {
                            connected = true
                            work(conn)
                        })
                        prev = conn
                    }
                }, 1000)
            } else {
                peer.on('connection', (conn) => {
                    conn.on('open', () => work(conn))
                    conn.on('close', reconnect_screen)
                })
            }
        });
        peer.on('close', reconnect_screen)
    }
</script>