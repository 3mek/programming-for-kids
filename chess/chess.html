<script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.3.2/peerjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ext-themelist.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/mode-javascript.min.js"></script>




<style>
    body,
    pre,
    textarea {
        font-family: monospace;
        font-size: 14px;
        margin: 0;
    }

    tiny {
        font-family: monospace;
    }

    iframe {
        display: none
    }

    #loading {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: black;
        color: white;
    }

    #editor {
        display: none;
    }

    #error {
        color: white;
        background-color: tomato;
    }
</style>
<div id='loading'>
    <h1>
        戦
    </h1>
    <p>
        Code is at: https://github.com/jackdoe/programming-for-kids<br><br>
        You need another player.<br>
        Send them this link to play:
    </p>
</div>
<div style="margin: 5px">
    <pre id='help'>
<span style='font-size: 20px'>戦</span>
<small>* Each piece can move: freely horizontally, and +- 5 vertically
* If you collide with the enemy you capture them
* Goal is to reach the end of the board with at least one piece or annihilate all enemies.
* You are playing <b>x</b>, oponent is playing <b>0</b>
* Contribute: https://github.com/jackdoe/programming-for-kids
</small>
</pre>
    <div id='error'></div>
    <button disabled id='a_go'>play</button><br>
    <div id="editor" style="height: 150px; width: 100%"></div>

    <pre id='game'></pre>
    <textarea id='enemy_code' disabled rows=10 cols=80></textarea>
</div>
<iframe sandbox='allow-scripts' src="frame.html" id='frame'></iframe>
<script>
    const sleep = function (ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // XXX: this is horrible, idk how safe it is even through the iframe sandbox
    const evaluate = async function (code) {
        const frame = document.getElementById('frame')
        frame.contentWindow.postMessage(code, '*');

        let data = undefined
        const cb = function (e) { data = e.data }
        window.addEventListener('message', cb);
        while (!data) {
            await sleep(100)
        }
        window.removeEventListener('message', cb)
        return data
    }

    const width = 20
    const height = 20
    const step = 4
    let entriesA = []
    let entriesB = []

    const key = function (x, y) {
        return x + '_' + y
    }

    const uuid = function () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    const to_positions = function (entries, cb) {
        let positions = {}
        for (let a of entries) {
            positions[key(a.x, a.y)] = cb(a)
        }
        return positions
    }

    const draw = function ({ home, away }) {
        const positionsB = to_positions(entriesB, e => ' <span title="idx:' + e.index + '">0</span>|')
        const positionsA = to_positions(entriesA, e => ' <span title="idx:' + e.index + '">x</span>|')
        const view = document.getElementById('game')

        let text = '\nalive: x(' + entriesA.length + '), 0(' + entriesB.length + ')\n\n'
        const line_of_dashes = () => {
            for (let x = 0; x < width; x++) {
                text += '---'
            }
            text += '--\n'
        }
        const x_labels = () => {
            text += '  '
            for (let x = 0; x < width; x++) {
                text += (x + '').padStart(2, ' ') + '|'
            }
            text += '\n'
        }
        x_labels()
        line_of_dashes()

        for (let y = 0; y < height; y++) {
            text += (y + '').padStart(2, ' ')
            for (let x = 0; x < width; x++) {
                let k = key(x, y)
                text += positionsA[k] || positionsB[k] || '  |'
            }
            text += '\n'
        }
        line_of_dashes()
        x_labels()
        text += '\n'
        let win = ''
        for (e of entriesA) {
            if ((home && e.y == height - 1) || ((away && e.y == 0))) {
                win = '\n\nYOU WIN!\n\n'
            }
        }

        for (e of entriesB) {
            if ((away && e.y == height - 1) || ((home && e.y == 0))) {
                win = '\n\nYOU LOSE!\n\n'
            }
        }
        if (entriesB.length == 0) {
            win = '\n\nYOU WIN!\n\n'
        }
        if (entriesA.length == 0) {
            win = '\n\nYOU LOSE!\n\n'
        }
        if (win) {
            a_go.parentElement.removeChild(a_go)
        }
        view.innerHTML = win + text
    }

    const randint = function (min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min)
    }

    const reset_pieces = function (where) {
        let home = []
        let away = []
        for (let i = 0; i < width; i++) {
            home.push({ index: home.length, x: i, y: 0, id: 'id-a-' + key(i, 0) + '-' + Math.random() })

            away.push({ index: away.length, x: i, y: height - 1, id: 'id-b-' + key(i, height - 1) + '-' + Math.random() })
        }
        if (where == 'home') {
            entriesA = home
            entriesB = away
        } else {
            entriesB = home
            entriesA = away
        }
    }


    const run = async (code, heroes, enemies) => {
        let grid = []

        for (let y = 0; y < height; y++) {
            grid[y] = []
            for (let x = 0; x < width; x++) {
                grid[y][x] = 0
            }
        }

        for (e of enemies) grid[e.y][e.x] = -1;
        for (h of heroes) grid[h.y][h.x] = -1;

        let message = '(' + code + ')(' + JSON.stringify({ heroes, enemies, width, height, grid }) + ')'
        let result = await evaluate(message)
        if (result.error) {
            throw (result.error)
        }

        if (!Array.isArray(result)) return heroes

        // remove out of bounds
        for (let r of result) {
            if (r.x < 0) r.x = 0
            if (r.y < 0) r.y = 0
            if (r.x > width - 1) r.x = width - 1
            if (r.y > height - 1) r.y = height - 1
        }


        // remove invalid ids
        byID = {}
        for (let h of heroes) {
            byID[h.id] = h
        }

        result = result.filter(r => byID[r.id])

        // check if positions differ too mucb
        for (let r of result) {
            let original = byID[r.id]

            // allow only step moves at a time
            if (Math.abs(r.y - original.y) > step) {
                console.log('illegal move', { abs: Math.abs(r.y - original.y), y: r.y, original_y: original.y })
                r.y = original.y;
            }
        }
        return result
    }

    let id = window.location.hash.substring(1)
    if (id.length < 3) {
        id = uuid() + '-a'
        window.location.hash = id
    }
    const is_home = id.endsWith('-a')
    const is_away = id.endsWith('-b')
    const peer = new Peer(id, {
        debug: 4,
        config: {
            'iceServers': [
                { url: 'stun:stun.l.google.com:19302' },
                { url: 'turn:txt.black:3478', credential: 'noooooooo111222', username:'chess' }
            ]
        }
    })

    const errorE = document.getElementById('error')
    const a_go = document.getElementById('a_go')
    const enemy_code = document.getElementById('enemy_code')
    const loading = document.getElementById('loading')
    const other = id.substring(0, id.length - 2) + (id.endsWith('-a') ? '-b' : '-a')
    loading.innerHTML += '<textarea style="color: white; background-color: black; border: 0px;resize: none" rows=1 disabled cols=100>' + window.location.href.split('#')[0] + '#' + other + '</textarea>'


    const reconnect_screen = () => {
        loading.innerHTML = 'connection closed, please refresh, and ask the other peer to refresh'
        loading.style.display = 'block'
        document.getElementById('editor').style.display = 'none'
    }
    peer.on('open', function (id) {
        let work = function (conn) {
            
            loading.style.display = 'none'
            document.getElementById("editor").style.display = 'block'
            var editor = ace.edit("editor");
            editor.getSession().setUseWorker(false);
            editor.setReadOnly(true)
            editor.getSession().setMode("ace/mode/javascript");
            editor.getSession().on('change', function () {
                conn.send(JSON.stringify({ code: editor.getValue() }))
            });

// x   x
//   x     -> @ black hole
// x   x       
//
// x   x
//  x x    -> & assassin
//   x
//
// xxx
// x x     -> ^ samurai
// xxx
            var plus_or_minus = is_home ? '+' : '-'
            var initial = `function evolve({ heroes, enemies, grid, width, height }) {
    for (let h of heroes) {
        let x = Math.floor(Math.random() * width)
        let y = h.y ${plus_or_minus} ${step}

        h.x = x
        h.y = y
    }
    return heroes
}
`
            editor.setValue(initial)
            editor.clearSelection()
            enemy_code.value = initial
            if (is_home) {
                a_go.removeAttribute('disabled')
                editor.setReadOnly(false)
                reset_pieces('home')
            } else {
                reset_pieces('away')
            }
            draw({ home: is_home, away: is_away })
            conn.on('data', async function (data) {
                let parsed = JSON.parse(data)
                if (!parsed.entriesA) {
                    enemy_code.value = parsed.code
                    return
                }
                entriesB = parsed.entriesA
                entriesA = parsed.entriesB

                enemy_code.value = parsed.code
                a_go.removeAttribute('disabled')
                editor.setReadOnly(false)
                draw({ home: is_home, away: is_away })
            });

            a_go.addEventListener('click', async () => {
                errorE.innerHTML = ''
                try {
                    entriesA = await run(editor.getValue(), entriesA, entriesB)
                    let positionsA = to_positions(entriesA, e => true)
                    entriesB = entriesB.filter(e => !positionsA[key(e.x, e.y)])

                    let positionsB = to_positions(entriesB, e => true)
                    entriesA = entriesA.filter(e => !positionsB[key(e.x, e.y)])

                    conn.send(JSON.stringify({ code: editor.getValue(), entriesA, entriesB }))

                    a_go.setAttribute('disabled', 'disabled')
                    editor.setReadOnly(true)
                    draw({ home: is_home, away: is_away })
                } catch (e) {
                    console.error('a', e)
                    errorE.innerHTML = 'error: ' + e
                }
            })
        }

        if (id.endsWith('-b')) {
            let conn = peer.connect(other)
            conn.on('open', () => {
                work(conn)
            })
            conn.on('close', reconnect_screen)
            conn.on('error', reconnect_screen)
        } else {
            peer.on('connection', (conn) => {
                conn.on('open', () => work(conn))
                conn.on('close', reconnect_screen)
                conn.on('error', reconnect_screen)
            })
        }
    });
    peer.on('close', reconnect_screen)
</script>