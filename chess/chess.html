<script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.3.2/peerjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ace.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/ext-themelist.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.12/mode-javascript.min.js"></script>




<style>
    body,
    pre,
    textarea {
        font-family: monospace;
        font-size: 14px;
        margin: 0;
    }

    tiny {
        font-family: monospace;
    }

    iframe {
        display: none
    }

    #loading {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: black;
        color: white;
    }

    #editor {
        display: none;
    }

    #error {
        color: white;
        background-color: tomato;
    }
</style>
<div id='loading'>
    <h1>
        戦
    </h1>
    <p>
        Code is at: https://github.com/jackdoe/programming-for-kids<br><br>
        You need another player.<br>
        Send them this link to play:
    </p>
</div>
<div style="margin: 5px">
    <pre id='help'>
<span style='font-size: 20px'>戦</span>
<small>* Each piece can move: freely horizontally, and +- 5 vertically
* If you collide with the enemy you capture them
* Goal is to reach the end of the board with at least one piece or annihilate all enemies.
* You are playing <b>x</b>, oponent is playing <b>0</b>
* Contribute: https://github.com/jackdoe/programming-for-kids
</small>
</pre>
    <div id='error'></div>
    <button disabled id='a_go'>play</button><br>
    <div id="editor" style="height: 150px; width: 100%"></div>

    <pre id='game'></pre>
    <textarea id='enemy_code' disabled rows=10 cols=80></textarea>
</div>
<iframe sandbox='allow-scripts' src="frame.html" id='frame'></iframe>
<script>
    const sleep = function (ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // XXX: this is horrible, idk how safe it is even through the iframe sandbox
    const evaluate = async function (code) {
        const frame = document.getElementById('frame')
        frame.contentWindow.postMessage(code, '*');

        let data = undefined
        const cb = function (e) { data = e.data }
        window.addEventListener('message', cb);
        while (!data) {
            await sleep(100)
        }
        window.removeEventListener('message', cb)
        return data
    }

    const width = 16
    const height = 32
    const step = 4
    let entriesA = []
    let entriesB = []

    const key = function (x, y) {
        return x + '_' + y
    }

    const uuid = function () {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }

    const to_positions = function (entries, cb) {
        let positions = {}
        for (let a of entries) {
            positions[key(a.x, a.y)] = cb(a, positions)
        }
        return positions
    }

    const draw = function ({ home, away }) {
        const render = (e, ab, counted) => {
            let symbol = '0'
            if (e.type == 'flag') symbol = '<b>@</b>'
            if (ab == 'b') {
                symbol = 'x'
                if (e.type == 'flag') symbol = '<b>%</b>'
            }
            let n = counted[key(e.x, e.y)]
            let colors = [
                'black',
                '#ff3366',
                '#ff6633',
                '#FFCC33',
                '#33FF66',
                '#33FFCC',
                '#33CCFF',
                '#3366FF',
                '#6633FF',
                '#CC33FF',
                '#efefef',
            ]
            return ` <span style="color: ${colors[n%colors.length-1]}" title="idx: ${e.index} x: ${e.x} y: ${e.y}, overlap: ${n}">${symbol}</span> |`
        }
        let countedA = {}
        for (let a of entriesA) {
            let k = key(a.x, a.y)
            countedA[k] = (countedA[k] || 0) + 1
        }
        let countedB = {}
        for (let a of entriesB) {
            let k = key(a.x, a.y)
            countedB[k] = (countedB[k] || 0) + 1
        }
        const positionsA = to_positions(entriesA, e => render(e, 'a', countedA))
        const positionsB = to_positions(entriesB, e => render(e, 'b', countedB))
        const view = document.getElementById('game')

        let text = '\nalive: x(' + entriesA.length + '), 0(' + entriesB.length + ')\n\n'
        const line_of_dashes = () => {
            for (let x = 0; x < width; x++) {
                text += '----'
            }
            text += '---\n'
        }
        const x_labels = () => {
            text += '  '
            for (let x = 0; x < width; x++) {
                text += (x + '').padStart(2, ' ') + ' |'
            }
            text += '\n'
        }
        x_labels()
        line_of_dashes()

        for (let y = 0; y < height; y++) {
            text += (y + '').padStart(2, ' ')
            for (let x = 0; x < width; x++) {
                let k = key(x, y)
                text += positionsA[k] || positionsB[k] || '   |'
            }
            text += '\n'
        }
        line_of_dashes()
        x_labels()
        text += '\n'
        let win = ''
        if (entriesA.filter(e => e.type == 'flag').length == 0) {
            win = away ? '\n\nYOU WIN!\n\n' : '\n\nYOU LOSE!\n\n'
        }
        if (entriesB.filter(e => e.type == 'flag').length == 0) {
            win = away ? '\n\nYOU WIN!\n\n' : '\n\nYOU LOSE!\n\n'
        }

        if (win) {
            a_go.parentElement.removeChild(a_go)
        }
        view.innerHTML = win + text
    }

    const randint = function (min, max) {
        return Math.floor(Math.random() * (max - min + 1) + min)
    }

    const reset_pieces = function (where) {
        let home = []
        let away = []

        home.push({ type: 'flag', index: home.length, x: parseInt(width / 2), y: parseInt(height / 4), id: uuid() })
        away.push({ type: 'flag', index: away.length, x: parseInt(width / 2), y: height - parseInt(height / 4) - 1, id: uuid() })

        for (let i = 0; i < width; i++) {
            home.push({ index: home.length, x: i, y: 0, id: uuid() })

            away.push({ index: away.length, x: i, y: height - 1, id: uuid() })
        }

        if (where == 'home') {
            entriesA = home
            entriesB = away
        } else {
            entriesB = home
            entriesA = away
        }
    }
    const to_grid_int = (heroes, enemies, cbH, cbE) => {
        const grid = []

        for (let y = 0; y < height; y++) {
            grid[y] = []
            for (let x = 0; x < width; x++) {
                grid[y][x] = 0
            }
        }

        for (e of enemies) grid[e.y][e.x] = cbE(e);
        for (h of heroes) grid[h.y][h.x] = cbH(h);
        return grid
    }
    const formation = (heroes, mask) => {

    }
    const run = async (code, heroes, enemies) => {

        let message = '(' + code + ')(' + JSON.stringify({
            heroes,
            enemies,
            width,
            height,
            grid: to_grid_int(heroes, enemies, (h) => 1, (e) => -1)
        }) + ')'
        let result = await evaluate(message)
        if (result.error) {
            throw (result.error)
        }

        if (!Array.isArray(result)) return heroes

        // remove out of bounds
        for (let r of result) {
            if (r.x < 0) r.x = 0
            if (r.y < 0) r.y = 0
            if (r.x > width - 1) r.x = width - 1
            if (r.y > height - 1) r.y = height - 1
        }
        byID = {}
        for (let h of heroes) {
            byID[h.id] = h
        }
        result = result.filter(r => byID[r.id])

        // check if positions differ too mucb
        for (let r of result) {
            let original = byID[r.id]
            if (original.type == 'flag') {
                r.x = original.x
                r.y = original.y
            }
            r.type = original.type

            // allow only step moves at a time
            if (Math.abs(r.y - original.y) > step) {
                console.log('illegal move', { abs: Math.abs(r.y - original.y), y: r.y, original_y: original.y })
                r.y = original.y;
            }
        }

        let positionsH = to_positions(result, e => true)
        enemies = enemies.filter(e => !positionsH[key(e.x, e.y)])

        let positionsE = to_positions(enemies, e => true)
        result = result.filter(e => !positionsE[key(e.x, e.y)])

        return { A: result, B: enemies }
    }

    let id = window.location.hash.substring(1)
    if (id.length < 3) {
        id = uuid() + '-a'
        window.location.hash = id
    }
    const is_home = id.endsWith('-a')
    const is_away = id.endsWith('-b')
    const peer = new Peer(id, {
        debug: 4,
        config: {
            'iceServers': [
                { url: 'stun:stun.l.google.com:19302' },
                { url: 'turn:txt.black:3478', credential: 'noooooooo111222', username: 'chess' }
            ]
        }
    })

    const errorE = document.getElementById('error')
    const a_go = document.getElementById('a_go')
    const enemy_code = document.getElementById('enemy_code')
    const loading = document.getElementById('loading')
    const other = id.substring(0, id.length - 2) + (id.endsWith('-a') ? '-b' : '-a')
    loading.innerHTML += '<textarea style="color: white; background-color: black; border: 0px;resize: none" rows=1 disabled cols=100>' + window.location.href.split('#')[0] + '#' + other + '</textarea>'


    const reconnect_screen = () => {
        loading.innerHTML = 'connection closed, please refresh, and ask the other peer to refresh'
        loading.style.display = 'block'
        document.getElementById('editor').style.display = 'none'
    }
    peer.on('open', function (id) {
        let work = function (conn) {

            loading.style.display = 'none'
            document.getElementById("editor").style.display = 'block'
            var editor = ace.edit("editor");
            editor.getSession().setUseWorker(false);
            editor.setReadOnly(true)
            editor.getSession().setMode("ace/mode/javascript");
            editor.getSession().on('change', function () {
                conn.send(JSON.stringify({ code: editor.getValue() }))
            });

            var initial = `function evolve({ heroes, enemies, grid, width, height }) {
    var flag = enemies[0]
    for (let h of heroes) {
        if (h.x < flag.x) h.x +=1
        if (h.x > flag.x) h.x -=1
        if (h.y < flag.y) h.y +=1
        if (h.y > flag.y) h.y -=1
    }
    return heroes
}`
            editor.setValue(initial)
            editor.clearSelection()
            enemy_code.value = initial
            if (is_home) {
                a_go.removeAttribute('disabled')
                editor.setReadOnly(false)
                reset_pieces('home')
            } else {
                reset_pieces('away')
            }
            draw({ home: is_home, away: is_away })
            conn.on('data', async function (data) {
                let parsed = JSON.parse(data)
                if (!parsed.entriesA) {
                    enemy_code.value = parsed.code
                    return
                }

                // XXX: validate the positions
                entriesB = parsed.entriesA
                entriesA = parsed.entriesB
                enemy_code.value = parsed.code
                a_go.removeAttribute('disabled')
                editor.setReadOnly(false)
                draw({ home: is_home, away: is_away })
            });

            a_go.addEventListener('click', async () => {
                errorE.innerHTML = ''
                try {
                    entries = await run(editor.getValue(), entriesA, entriesB)
                    entriesA = entries.A
                    entriesB = entries.B

                    conn.send(JSON.stringify({ code: editor.getValue(), entriesA, entriesB }))

                    a_go.setAttribute('disabled', 'disabled')
                    editor.setReadOnly(true)
                    draw({ home: is_home, away: is_away })
                } catch (e) {
                    console.error('a', e)
                    errorE.innerHTML = 'error: ' + e
                }
            })
        }

        if (id.endsWith('-b')) {
            let conn = peer.connect(other)
            conn.on('open', () => {
                work(conn)
            })
            conn.on('close', reconnect_screen)
            conn.on('error', reconnect_screen)
        } else {
            peer.on('connection', (conn) => {
                conn.on('open', () => work(conn))
                conn.on('close', reconnect_screen)
                conn.on('error', reconnect_screen)
            })
        }
    });
    peer.on('close', reconnect_screen)
</script>